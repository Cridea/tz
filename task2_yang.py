def min_steps_to_same(arr, k):
    target = arr[0] # принимает первое значение массива
    steps = 0
    for num in arr:
        if num != target: # сравнивает каждый элемент массива с первым
            steps += 1
    if steps > k or (k - steps) % len(arr) != 0: #Проверка возможности сделать все элементы массива одинаковыми с помощью операции удаления и добавления элементов. 
        return -1 #Если минимальное количество шагов, необходимое для превращения всех элементов в target, превышает k, или разница между k и steps не делится нацело на длину массива, возвращаем -1, так как преобразование невозможно.
    return (k - steps) // len(arr)

# Пример 
arr = [1, 2, 3]
k = 5
result = min_steps_to_same(arr, k)
if result == -1:
    print("Невозможно сделать все элементы массива одинаковыми.")
else:
    print(f"Минимальное количество шагов: {result}")
